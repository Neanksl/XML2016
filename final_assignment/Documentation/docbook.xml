<?xml version="1.0" encoding="UTF-8"?>
<?xml-model href="http://www.oxygenxml.com/docbook/xml/5.0/rng/dbsvg.rng" schematypens="http://relaxng.org/ns/structure/1.0"?>
<?xml-model href="http://docbook.org/xml/5.0/rng/docbook.rng" type="application/xml" schematypens="http://purl.oclc.org/dsdl/schematron"?>

<!DOCTYPE article PUBLIC "ARTICLE" "docbook.dtd">
<?xml-stylesheet type="text/css" href="./css/docbook.css"?>

<article xmlns="http://docbook.org/ns/docbook" xmlns:xlink="http://www.w3.org/2001/xlink" version="5.0">
    <info>
        <title>
            <emphasis> Mancala </emphasis>
        </title>
        <subtitle>Praktikum: XML-Technologie</subtitle>
        <pubdate>01.07.2016</pubdate>
    </info>
    <para>
        <wordasword>Mancala</wordasword>, also Manqala or Mancala, is a very popular ancient game with numerous variations. This count-and-capture game can be played 
        by two people, with the aim of winning the most "seeds" on the "field". </para>
    <section>
        <title>Introduction</title>
        <para>
            <emphasis role="underline">Type</emphasis> Board game</para>
        <para>
            <emphasis role="underline">Number of players</emphasis> Mostly two </para>
        <para>At the beginning of the game, a <emphasis role="bold">Mancala-Playboard</emphasis> is
            needed. The board will be seperated into 2 rows. Each player has 6 small <emphasis
                role="bold">"houses"</emphasis> on their side, and a big <emphasis role="bold">"store"
            </emphasis> - which also called <emphasis role="bold">Kalah</emphasis> - where the
            stones are to be collected and stored. In this lab course, we chose the Kalah-version,
            which uses 48 "seeds" equally distributed in 12 houses.</para>
    </section>
    
    <section>
        <title>Playing rules</title>
        <para>
            <emphasis role="underline">
                <emphasis role="bold">Game objective</emphasis>
            </emphasis>
            : The objective of the game is to capture more seeds than the opponent. </para>
        
        <itemizedlist mark="opencircle">
            <listitem>
                <para>Player begins by choosing a house at his option and starts distributing the
                    seeds around the board until there is no seed left in his hand. The seeds should
                    be dropped one-by-one and in counterclockwise direction. The opponent's Kalah
                    should be skipped. </para>
            </listitem>
            <listitem>
                <para>If the last seed is dropped into the player's Kalah, he got an extra turn. </para>
            </listitem>
            <listitem>
                <para>If the last seed falls into an empty house owned by the player, player is
                    allowed to capture all the seeds of the opposite house and store them in his own
                    Kalah. </para>
            </listitem>
            <listitem>
                <para>The player who still has seeds on his side of the board when the opponent's
                    houses are empty captures all of those.</para>
            </listitem>
            <listitem>
                <para>The game ends where one player has no seeds left. The player with
                    the most seeds wins the game. </para>
            </listitem>
        </itemizedlist>
    </section>
    
    <section>
        <title>Technologies</title>
        <para>In this lab course, there were many of XML-Technologies used. 
            <itemizedlist mark="opencircle">
                <listitem>
                    <para> SVG: Scalable Vector Graphics, helps describing two-dimensional graphics for the Web with support for interactivity and animation.</para>
                </listitem>    
                <listitem>
                    <para> XSLT, XSL: EXtensible Stylesheet Language is a part of XSL, which is the stylesheet language for XML. XSLT helps transforming XML Documents into other XML Documents.</para>
                </listitem>
                <listitem>    
                    <para> XQuery is to XML what SQL is to database tables. XML Data will be queried thanks to XQuery.  </para>
                </listitem>    
                <listitem>    
                    <para> BaseX: scalable, high performance XML Database engine which allows querying and storing XML on the net.</para>
                </listitem>
            </itemizedlist>
        </para>
    </section>
    
    <section>
        <title>Diagrams</title>
        <para>Use Cases and Use Case Diagram
            The mancala game can be splitted up in the following usecases:
            <itemizedlist>
                <listitem>
                    <para>
                        Initially the players want to be able to start a new game of mancala.
                    </para>
                    <itemizedlist>
                        <listitem>
                            <para>
                                The players also want to have the possibility to discard the current game and restart it.
                            </para>
                        </listitem>
                    </itemizedlist>
                </listitem>
                <listitem>
                    <para>
                        Each player wants to be able to make specific moves.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        TODO The players want to be able to win the game and see how many games they have won so far.
                    </para>
                </listitem>
                <listitem>
                    <para>
                        TODO If the players decide to continue the match later, they want to be able to save and load the game.
                    </para>
                </listitem>
            </itemizedlist>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="./../Diagrams/UseCases.pdf"
                    />
                </imageobject>
            </mediaobject>
        </para>
        
        <section>
            <title>Architecture</title>
            <para>
                The following diagram show the architecture of our implementation of the Mancala game. The architecture can be divided in three components, which are also a representation for the MVC (model view controller) pattern.
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>Database</emphasis>:
                            The database represents the storage for one gamestate. That means one current instance of the game is saved in the database.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Client</emphasis>:
                            The client is the frontend of the application, i.e. the user interaction interface. Any action from the players will be forwarded as a RESTful request to the server. 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Server</emphasis>:
                            The server receives the requests (actions) from the client and then acts as a controller by deciding if a new gamestate should be created or the existing gamestate (currently saved on the database) should be edited. Independently from that decision the new gamestate will be stored in the database and a visual representation of this gamestate is being returned to the client.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="./../Diagrams/Architecture.pdf"
                    />
                </imageobject>
            </mediaobject>
        </section>
        
        <section>
            <title>Sequence</title>
            <para>
                Each of the following sequence diagrams describe a chain of events that is triggered when a player interacts with the system. These events are actions between the four entities:
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>Client</emphasis>:
                            The client is the user interface, which serves the user as visual representation of the application. If a user interacts with the system, the interaction is aimed at a component shown by the client.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Controller</emphasis>:
                            The controller represents the application controller. It forwards requests from the frontend to the backend and it triggers updates of the client, if new data are available.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Game</emphasis>:
                            The game is implemented as the server of the application. Different frontends (Client and Controller) can interact with this server, i.e. the game. Therefore, it also acts as a controller but its scope is only a instance of the mancala game. 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Database</emphasis>:
                            This entity stores the active gamestates. A gamestate is an instance of the current game. Each game always has one gamestate that can be saved.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <section>
                <title>Create game</title>
                <para>
                    TODO MICHI In order to start a new game the player can press the "New game"/"Start over" button or one of his houses. 
                    <orderedlist>
                        <listitem>
                            <para>
                                <emphasis>click</emphasis>:
                                The user clicked on the according objects shown by the Client.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>newGame()</emphasis>:
                                The client evaluates the click, for example, on the "New game" button. Then the client sends the newGame() request to the controller in order to instanciate a new game. Now the Client is waiting for a response of the controller.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>newGame()</emphasis>:
                                The controller received the newGame() request from the client and forwards it to the server, i.e. the game.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>createGameState()</emphasis>:
                                After receiving the request for a new game the game creates a new instance of the mancala game with the initial settings.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>setGameState()</emphasis>:
                                The just instanciated gamestate is immediately sent to the database where it is being stored.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>gamestate</emphasis>:
                                Now the game sends the gamestate to the controller as response for the newGame() request from the controller (Nr. 3).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>updateGameStateView()</emphasis>:
                                The Controller generates the SVG which can represents the current gamestate.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>gameStateSVG</emphasis>:
                                The just generated SVG is now sent to the client as response for the newGame() request (Nr. 2).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>refreshView()</emphasis>:
                                Finally the Client refreshs its view and the user can now see the game with the initial settings.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="./../Diagrams/Sequence_createGame.pdf"
                        />
                    </imageobject>
                </mediaobject>
            </section>
            <section>
                <title>Select a house</title>
                <para>
                    TODO MICHI In order to make a move, a player can click in the browser on a house and trigger the intended move. 
                    <orderedlist>
                        <listitem>
                            <para>
                                <emphasis>click</emphasis>:
                                The user clicked a house to start the game.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>clickedHouse(int)</emphasis>:
                                The client evaluates the click to be a click on a house with a specific index. Then the client sends the clickedHouse(int) request with the regarding index as parameter to the controller in order to trigger the player move. Now the Client is waiting for a response of the controller.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>clickedHouse(int)</emphasis>:
                                The controller received the clickedHouse(int) request from the client and forwards it to the server, i.e. the game.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>getGameState()</emphasis>:
                                The server now requests the current state of the game from the database.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>gamestate</emphasis>:
                                The database returns the current gamestate.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>updateGameState()</emphasis>:
                                After receiving the current gamestate the server evaluates the move which was triggered by the player and updates the gamestate appropriately.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>setGameState()</emphasis>:
                                The just updated gamestate is immediately sent to the database where it is being stored.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>gamestate</emphasis>:
                                Now the game sends the gamestate to the controller as response for the clickedHouse(int) request from the controller (Nr. 3).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>updateGameStateView()</emphasis>:
                                The Controller generates the SVG which can represents the current gamestate.
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>gameStateSVG</emphasis>:
                                The just generated SVG is now sent to the client as response for the clickedHouse(int) request (Nr. 2).
                            </para>
                        </listitem>
                        <listitem>
                            <para>
                                <emphasis>refreshView()</emphasis>:
                                Finally the Client refreshs its view and the user can now see the game with the initial settings.
                            </para>
                        </listitem>
                    </orderedlist>
                </para>
                <mediaobject>
                    <imageobject>
                        <imagedata
                            fileref="./../Diagrams/Sequence_clickHouse.pdf"
                        />
                    </imageobject>
                </mediaobject>
            </section>
        </section>
        
        <section>
            <title>Classes</title>
            <para>
                The following list explains the classes shown in the class diagram.
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>Player</emphasis>:
                            The Player class represents one of two players. It has an ID to differentiate between the players and each player has a winCount, which contains the amount of won games. Thereby it has the method to increase the winCount after a won match and the method to reset the winCount if the game session has came to an end.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Players</emphasis>:
                            The Players class is the controller of two Player classes. It remembers which players turn it is and provides the according methods to set/get/toggle the player turn. 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>GameObject</emphasis>:
                            The GameObject is an abstract class which works as a superclass for the House and the Store class. 
                            To identify the different GameObjects they contain the property ID. Furthermore, each GameObject tracks the amount of seeds in it and provide the appropriate methods to get/set/increment the current seedCount.
                            The Store and the House classes has up to now the exact same attributes and methods as their superclass.
                        </para>
                        <itemizedlist>
                            <listitem>
                                <para>
                                    <emphasis>House</emphasis>:
                                    The houses represents the holes on the board in which the seeds will sit in.  
                                </para>
                            </listitem>
                            <listitem>
                                <para>
                                    <emphasis>Store</emphasis>:
                                    The store is the slightly bigger house, which stores all the seeds a player won. Therefore, each player has only one store.
                                </para>
                            </listitem>
                        </itemizedlist>
                        
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Layer</emphasis>:
                            The Layer class is just a wrapper class for the store and the houses of one player. Since a player has six houses and one store it consists exactly of six houses and one store. Furthermore, the Layer class contains the attribute position, which is an enumeration of either "top" or "bottom". 
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Board</emphasis>:
                            The board is the contoller class for the mancala board. It consists of two layers - one top and one bottom layer. The board is able to get a hosue or a store by its ID so that the appropriate method (inSeedCount) can be called if a player clicks on a house. The board also wraps getting a house/store and calling its incSeedCount by the handler method clickedHouse, which is called if a player clicks on a house. Finally the board contains the resetBoard method, which sets the board to its initial setup.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Game</emphasis>:
                            The game is the top level controller of one instance of a game. It consists of the Board and the Players class and after calling the contructor the currentGame property is instanciated. Additionally it has the method to reset the current game.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
            <mediaobject>
                <imageobject>
                    <imagedata
                        fileref="./../Diagrams/Classes.pdf"
                    />
                </imageobject>
            </mediaobject>
        </section>
    </section>
    
    <section>
        <title>Implementation</title>
        
        <section>
            <title>Filestructure</title>
            <para>
                The following list shows the files, which were used to implement the basic functionalities of XQuery for mancala.
                <itemizedlist>
                    <listitem>
                        <para>
                            <emphasis>initial_gamestate.xml</emphasis>:
                            Contains all initial elements (initial values for a game to start) shown in the class diagram with according mulitplicity.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>Static.xml</emphasis>:
                            Combines and transforms current gamestates from server with static measurement input values to create an SVG file that displays the Mancala board.
                            Contains a number of measurement input values (such as horizontal/vertiacal distance between houses, distance between stores and nearest houses etc), so that the Mancala board can be automatically created (see "Transform.xsl").
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>mancala.xqm</emphasis>:
                            Contains all methods described in the class diagram.
                        </para>
                    </listitem>
                </itemizedlist>
            </para>
        </section>
        
        
        <section>
            <title>OOP, namespaces and naming conventions</title>
            <para>In order to realise the architecture represented in the classdiagram we introduced multiple namespaces, to simulate class-scopes. Since only classes with methods received their own namespace, the layer and the position are the only classes which do not have an explicit namespace. Accordingly each method is defined in the namespace of its class.</para>
        </section>
        
        <section>
            <title>Single Node Updates</title>
            <para>As XQuery updates are gathered and applied at once the end of the XQuery script, nodes cannot be updated multiple times. Therefore, the amount of seeds is calculated and each house is updated only once.</para>
        </section>
        
        <section>
            <title>Index DB</title>
            <para>TODO: IndexDB for games: At first startup, the index-db has to be initialized.</para>
        </section>
        
         <section>
             <title>TODO</title>
            <para>TODO: node manipulation by reference</para>
            <para>TODO: recursive node distribution</para>
            <para>By marking a function <emphasis>updating</emphasis>, FLWOR statements cannot be used inside the function scope. To mitigate this issue, updating functions use getters on composite objects instead of local <emphasis>let</emphasis> variables.</para>
            <para>TODO: forwarding to circumvent update issues</para>
        </section>
        
    
       
        
        <section>
            <title>Graphical User Interface (GUI)</title>
            <para>The project's homepage delivers the main GUI, which is an SVG file as shown below:</para>
            <mediaobject>
                <imageobject>
                    <imagedata  format="SVG"  fileref="./../Diagrams/Initial_Board.svg"/>
                </imageobject>
            </mediaobject>
            
            <para>
                The shown Mancala board contains:
                <itemizedlist>
                    <listitem>
                        <para>
                            12 houses, 6 for each player. Player 1 owns the upper houses, player 2 the lower.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            2 stores, 1 for each player. Player 1's store is on the left and player 2's on the right.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Game buttons, such as:
                            <listitem>
                                <emphasis>New Game</emphasis>: creates a new game instance without affecting players' scores.</listitem>
                            <listitem>
                                <emphasis>Reset Scores</emphasis>: creates a new game instance and reset ALL players' scores.</listitem>
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            The text in the middle indicates current game status, for example: which player is playing or if one player has won. Players' turns are hinted by a typical color and a blinking triangle in the corresponding store. In case of winning, the status text in the middle will point to the left or right depending on which player has won.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Each house is a clickable object. However, the current player can only select his own stores that have positive (> 0) number of stones. In addition the shown digits, the corresponding amount of stones is also displayed as a set of dots, each of which represents one stone. 
                        </para>
                    </listitem>
                </itemizedlist>
                <para>An example of a gamestate after several turns:</para>
                <mediaobject>
                    <imageobject>
                        <imagedata  format="SVG"  fileref="./../Diagrams/In_Game_Board.svg"/>
                    </imageobject>
                </mediaobject>
            
                <para>An example of a gamestate, in which player 1 has won:</para>
                <mediaobject>
                    <imageobject>
                        <imagedata  format="SVG"  fileref="./../Diagrams/In_Game_Board.svg"/>
                    </imageobject>
                </mediaobject>
            </para>
            
            <para>
                The main process of storing and transforming data from server to GUI as an SVG file can be described in the following steps:
                <orderedlist>
                    <listitem>
                        <para>
                            <emphasis>SVG outline definition</emphasis>:
                            The board's "skeleton" is defined by <emphasis>Static.xml</emphasis> stored in the server.
                            This XML file contains very few static measurements that draws the GUI's layout, such as width, height, distance between objects etc.
                            Based on these values, the rest can be automatically computed in the later stage, which hence ensures the model's flexibility and easiness for later adjustment.
                            Styles for these objects (e.g. houses, stores, seeds etc.) are also stored and can be adjusted anytime.
                            In this step, the most important part is to organize required tags in a meaning structure.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>SVG data source</emphasis>:
                            Game data (such as number of seeds in each house, whose turn it is etc.) is store in the server and can be retrieved by a RESTful request.
                            The gamestate fetched can then be processed and displayed on the board. The gamestate is seperated from the static measurements to save storage space and increase request processing time.
                            The data source must conform to the SVG outline.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            <emphasis>SVG transformation</emphasis>:
                            <emphasis>Transform.xsl</emphasis> combines both SVG outline and data source into one single SVG file, which is displayed by default on the project's homepage (i.e. http://localhost:8984/).
                            Based on the two XML sources, the XSL file calculates, creates, aligns and assigns styles to all objects shown on the board.
                            Some of the techniques that are used to implement the transformation are:
                            <itemizedlist>
                                <listitem>
                                    <para>
                                        <emphasis>defs</emphasis> and <emphasis>use</emphasis> tags to reuse objects
                                        <emphasis>if</emphasis> or <emphasis>choose</emphasis>, <emphasis>when</emphasis> and <emphasis>otherwise</emphasis> tags to handle different data states
                                        <emphasis>call-template</emphasis> and <emphasis>template</emphasis> tags to enable recursion with parameters over repeated work
                                    </para>
                                </listitem>
                            </itemizedlist>
                        </para>
                    </listitem>                
                </orderedlist>
            </para>
        </section>
        
        <section>
            <title>TODOs</title>
            <warning>
                <itemizedlist>
                    <listitem>
                        <para>
                            Eine Beschreibung der Requests und Responses zwischen Client und Server nach dem REST-Prinzip und ihre Abbildung auf Queries mit restXQ.
                        </para>
                    </listitem>
                    <listitem>
                        <para>
                            Eine Beschreibung der Benutzeroberfläche für die verschiedenen Stadien des Spiels mit den jeweiligen Interaktionsmüglichkeiten.
                        </para>
                    </listitem>
                </itemizedlist>
            </warning>
        </section>
    </section>
    
    
    
    <section>
        <title>Future Work</title>
        <para>The game could be improved by adding the following additional features</para>
        
        <section>
            <title>Play against the computer</title>
            <para>The player has the possibility to choose between playing against a real opponent
                or against the computer. When a game against the computer is selected, the player
                can chose the difficulty level of the game. There are 3 options available - easy,
                medium, difficult.</para>
        </section>
        <section>
            <title>Allow multiple pairs of users to play simultaneously</title>
            <para>Currently, the mancala application can only save the state of one game which
                limits it to allowing only two users to play. In order to extend the service and
                support a multiple number of games simultaneously, each game state should be
                preserved separatelly.</para>
        </section>
        <section>
            <title>User Ranking</title>
            <para>Allowing multiple games at the same time asumes a bigger number of users. Adding a
                user ranking and statistics would provide the players with a better overview of
                their own performance as well as of their competitors. The statistics could be
                integrated into each user's profile, showing the amount of games he/she won or lost.
                A hall of fame listing the best 5 players of all time could be an additional
                motivation for the users.</para>
        </section>
        <section>
            <title>User Network</title>
            <para>Building a user network allows the inegration of many additional features which
                can improve the user experience. As mentoined above, each use will have a profile
                that shows his statistics. The profile will also be visible for other players.
                Additional features could include challenging a user, chat as well as offline
                messaging.</para>
        </section>
        <section>
            <title>Animation</title>
            <para>Adding animation and special effects to the game play would also have a positive
                impact on the user experience. An example for such special effects is animating the
                movement of the seeds or adding sound effects when a seed get into the user's
                store.</para>
        </section>
    </section>
</article>
