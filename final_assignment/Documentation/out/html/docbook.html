<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Mancala</title><meta name="generator" content="DocBook XSL Stylesheets V1.78.1"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div class="article"><div class="titlepage"><div><div><h1 class="title"><a name="d5e1"></a>
            <span class="emphasis"><em> Mancala </em></span>
        </h1></div><div><h3 class="subtitle"><i>Praktikum: XML-Technologie</i></h3></div><div><p class="pubdate">01.07.2016</p></div></div><hr></div><div class="toc"><p><b>Table of Contents</b></p><dl class="toc"><dt><span class="section"><a href="#d5e9">Introduction</a></span></dt><dt><span class="section"><a href="#d5e20">Playing rules</a></span></dt><dt><span class="section"><a href="#d5e36">Technologies</a></span></dt><dt><span class="section"><a href="#d5e48">Diagrams</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e66">Architecture</a></span></dt><dt><span class="section"><a href="#d5e82">Sequence</a></span></dt><dt><span class="section"><a href="#d5e172">Classes</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e204">Implementation</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e206">Filestructure</a></span></dt><dt><span class="section"><a href="#d5e219">OOP, namespaces and naming conventions</a></span></dt><dt><span class="section"><a href="#d5e225">Index DB</a></span></dt><dt><span class="section"><a href="#d5e229">Single Node Updates</a></span></dt><dt><span class="section"><a href="#d5e232">FLOWR vs. Updating-statements</a></span></dt><dt><span class="section"><a href="#d5e237">Graphical User Interface (GUI)</a></span></dt><dt><span class="section"><a href="#d5e296">TODOs</a></span></dt></dl></dd><dt><span class="section"><a href="#d5e304">Future Work</a></span></dt><dd><dl><dt><span class="section"><a href="#d5e307">Play against the computer</a></span></dt><dt><span class="section"><a href="#d5e310">Allow multiple pairs of users to play simultaneously</a></span></dt><dt><span class="section"><a href="#d5e313">User Ranking</a></span></dt><dt><span class="section"><a href="#d5e316">User Network</a></span></dt><dt><span class="section"><a href="#d5e319">Animation</a></span></dt></dl></dd></dl></div><p>
        <em class="wordasword">Mancala</em>, also Manqala or Mancala, is a very popular ancient game
        with numerous variations. This count-and-capture game can be played by two people, with the
        aim of winning the most "seeds" on the "field". </p><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e9"></a>Introduction</h2></div></div></div><p>
            <span class="underline">Type</span> Board game</p><p>
            <span class="underline">Number of players</span> Mostly two </p><p>At the beginning of the game, a <span class="bold"><strong>Mancala-Playboard</strong></span> is
            needed. The board will be seperated into 2 rows. Each player has 6 small <span class="bold"><strong>"houses"</strong></span> on their side, and a big <span class="bold"><strong>"store" </strong></span> - which also called <span class="bold"><strong>Kalah</strong></span> -
            where the stones are to be collected and stored. In this lab course, we chose the
            Kalah-version, which uses 48 "seeds" equally distributed in 12 houses.</p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e20"></a>Playing rules</h2></div></div></div><p>
            <span class="underline">
                <span class="bold"><strong>Game objective</strong></span>
            </span> : The objective of the game is to capture more seeds than the opponent. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p>Player begins by choosing a house at his option and starts distributing the
                    seeds around the board until there is no seed left in his hand. The seeds should
                    be dropped one-by-one and in counterclockwise direction. The opponent's Kalah
                    should be skipped. </p></li><li class="listitem" style="list-style-type: circle"><p>If the last seed is dropped into the player's Kalah, he got an extra turn.
                </p></li><li class="listitem" style="list-style-type: circle"><p>If the last seed falls into an empty house owned by the player, player is
                    allowed to capture all the seeds of the opposite house and store them in his own
                    Kalah. </p></li><li class="listitem" style="list-style-type: circle"><p>The player who still has seeds on his side of the board when the opponent's
                    houses are empty captures all of those.</p></li><li class="listitem" style="list-style-type: circle"><p>The game ends where one player has no seeds left. The player with the most
                    seeds wins the game. </p></li></ul></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e36"></a>Technologies</h2></div></div></div><p>In this lab course, there were many of XML-Technologies used. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: opencircle; "><li class="listitem" style="list-style-type: circle"><p> SVG: Scalable Vector Graphics, helps describing two-dimensional graphics
                        for the Web with support for interactivity and animation.</p></li><li class="listitem" style="list-style-type: circle"><p> XSLT, XSL: EXtensible Stylesheet Language is a part of XSL, which is the
                        stylesheet language for XML. XSLT helps transforming XML Documents into
                        other XML Documents.</p></li><li class="listitem" style="list-style-type: circle"><p> XQuery is to XML what SQL is to database tables. XML Data will be queried
                        thanks to XQuery. </p></li><li class="listitem" style="list-style-type: circle"><p> BaseX: scalable, high performance XML Database engine which allows
                        querying and storing XML on the net.</p></li></ul></div><p>
        </p></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e48"></a>Diagrams</h2></div></div></div><p>Use Cases and Use Case Diagram The mancala game can be splitted up in the following
            usecases: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Initially the players want to be able to start a new game of mancala. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p> The players also want to have the possibility to discard the
                                current game and restart it. </p></li></ul></div></li><li class="listitem"><p> Each player wants to be able to make specific moves. </p></li><li class="listitem"><p> TODO The players want to be able to win the game and see how many games
                        they have won so far. </p></li><li class="listitem"><p> TODO If the players decide to continue the match later, they want to be
                        able to save and load the game. </p></li></ul></div><p>
            </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/UseCases.svg"></object></div><p>
        </p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e66"></a>Architecture</h3></div></div></div><p> The following diagram show the architecture of our implementation of the Mancala
                game. The architecture can be divided in three components, which are also a
                representation for the MVC (model view controller) pattern. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <span class="emphasis"><em>Database</em></span>: The database represents the storage for
                            one gamestate. That means one current instance of the game is saved in
                            the database. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Client</em></span>: The client is the frontend of the
                            application, i.e. the user interaction interface. Any action from the
                            players will be forwarded as a RESTful request to the server. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Server</em></span>: The server receives the requests (actions)
                            from the client and then acts as a controller by deciding if a new
                            gamestate should be created or the existing gamestate (currently saved
                            on the database) should be edited. Independently from that decision the
                            new gamestate will be stored in the database and a visual representation
                            of this gamestate is being returned to the client. </p></li></ul></div><p>
            </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/Architecture.svg"></object></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e82"></a>Sequence</h3></div></div></div><p> Each of the following sequence diagrams describe a chain of events that is
                triggered when a player interacts with the system. These events are actions between
                the four entities: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <span class="emphasis"><em>Client</em></span>: The client is the user interface, which
                            serves the user as visual representation of the application. If a user
                            interacts with the system, the interaction is aimed at a component shown
                            by the client. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Controller</em></span>: The controller represents the
                            application controller. It forwards requests from the frontend to the
                            backend and it triggers updates of the client, if new data are
                            available. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Game</em></span>: The game is implemented as the server of the
                            application. Different frontends (Client and Controller) can interact
                            with this server, i.e. the game. Therefore, it also acts as a controller
                            but its scope is only a instance of the mancala game. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Database</em></span>: This entity stores the active gamestates.
                            A gamestate is an instance of the current game. Each game always has one
                            gamestate that can be saved. </p></li></ul></div><p>
            </p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e98"></a>Create game</h4></div></div></div><p> TODO MICHI In order to start a new game the player can press the "New
                    game"/"Start over" button or one of his houses. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                                <span class="emphasis"><em>click</em></span>: The user clicked on the according
                                objects shown by the Client. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>newGame()</em></span>: The client evaluates the click, for
                                example, on the "New game" button. Then the client sends the
                                newGame() request to the controller in order to instanciate a new
                                game. Now the Client is waiting for a response of the controller.
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>newGame()</em></span>: The controller received the
                                newGame() request from the client and forwards it to the server,
                                i.e. the game. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>createGameState()</em></span>: After receiving the request
                                for a new game the game creates a new instance of the mancala game
                                with the initial settings. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>setGameState()</em></span>: The just instanciated gamestate
                                is immediately sent to the database where it is being stored.
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>gamestate</em></span>: Now the game sends the gamestate to
                                the controller as response for the newGame() request from the
                                controller (Nr. 3). </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>updateGameStateView()</em></span>: The Controller generates
                                the SVG which can represents the current gamestate. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>gameStateSVG</em></span>: The just generated SVG is now
                                sent to the client as response for the newGame() request (Nr. 2).
                            </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>refreshView()</em></span>: Finally the Client refreshs its
                                view and the user can now see the game with the initial settings.
                            </p></li></ol></div><p>
                </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/Sequence_createGame.svg"></object></div></div><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e132"></a>Select a house</h4></div></div></div><p> TODO MICHI In order to make a move, a player can click in the browser on a
                    house and trigger the intended move. </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                                <span class="emphasis"><em>click</em></span>: The user clicked a house to start the
                                game. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>clickedHouse(int)</em></span>: The client evaluates the
                                click to be a click on a house with a specific index. Then the
                                client sends the clickedHouse(int) request with the regarding index
                                as parameter to the controller in order to trigger the player move.
                                Now the Client is waiting for a response of the controller. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>clickedHouse(int)</em></span>: The controller received the
                                clickedHouse(int) request from the client and forwards it to the
                                server, i.e. the game. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>getGameState()</em></span>: The server now requests the
                                current state of the game from the database. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>gamestate</em></span>: The database returns the current
                                gamestate. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>updateGameState()</em></span>: After receiving the current
                                gamestate the server evaluates the move which was triggered by the
                                player and updates the gamestate appropriately. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>setGameState()</em></span>: The just updated gamestate is
                                immediately sent to the database where it is being stored. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>gamestate</em></span>: Now the game sends the gamestate to
                                the controller as response for the clickedHouse(int) request from
                                the controller (Nr. 3). </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>updateGameStateView()</em></span>: The Controller generates
                                the SVG which can represents the current gamestate. </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>gameStateSVG</em></span>: The just generated SVG is now
                                sent to the client as response for the clickedHouse(int) request
                                (Nr. 2). </p></li><li class="listitem"><p>
                                <span class="emphasis"><em>refreshView()</em></span>: Finally the Client refreshs its
                                view and the user can now see the game with the initial settings.
                            </p></li></ol></div><p>
                </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/Sequence_clickHouse.svg"></object></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e172"></a>Classes</h3></div></div></div><p> The following list explains the classes shown in the class diagram. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <span class="emphasis"><em>Player</em></span>: The Player class represents one of two
                            players. It has an ID to differentiate between the players and each
                            player has a winCount, which contains the amount of won games. Thereby
                            it has the method to increase the winCount after a won match and the
                            method to reset the winCount if the game session has came to an end.
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Players</em></span>: The Players class is the controller of two
                            Player classes. It remembers which players turn it is and provides the
                            according methods to set/get/toggle the player turn. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>GameObject</em></span>: The GameObject is an abstract class
                            which works as a superclass for the House and the Store class. To
                            identify the different GameObjects they contain the property ID.
                            Furthermore, each GameObject tracks the amount of seeds in it and
                            provide the appropriate methods to get/set/increment the current
                            seedCount. The Store and the House classes has up to now the exact same
                            attributes and methods as their superclass. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <span class="emphasis"><em>House</em></span>: The houses represents the holes on
                                    the board in which the seeds will sit in. </p></li><li class="listitem"><p>
                                    <span class="emphasis"><em>Store</em></span>: The store is the slightly bigger
                                    house, which stores all the seeds a player won. Therefore, each
                                    player has only one store. </p></li></ul></div></li><li class="listitem"><p>
                            <span class="emphasis"><em>Layer</em></span>: The Layer class is just a wrapper class for
                            the store and the houses of one player. Since a player has six houses
                            and one store it consists exactly of six houses and one store.
                            Furthermore, the Layer class contains the attribute position, which is
                            an enumeration of either "top" or "bottom". </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Board</em></span>: The board is the contoller class for the
                            mancala board. It consists of two layers - one top and one bottom layer.
                            The board is able to get a hosue or a store by its ID so that the
                            appropriate method (inSeedCount) can be called if a player clicks on a
                            house. The board also wraps getting a house/store and calling its
                            incSeedCount by the handler method clickedHouse, which is called if a
                            player clicks on a house. Finally the board contains the resetBoard
                            method, which sets the board to its initial setup. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Game</em></span>: The game is the top level controller of one
                            instance of a game. It consists of the Board and the Players class and
                            after calling the contructor the currentGame property is instanciated.
                            Additionally it has the method to reset the current game. </p></li></ul></div><p>
            </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/Classes.svg"></object></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e204"></a>Implementation</h2></div></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e206"></a>Filestructure</h3></div></div></div><p> The following list shows the files, which were used to implement the basic
                functionalities of XQuery for mancala. </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                            <span class="emphasis"><em>initial_gamestate.xml</em></span>: Contains all initial
                            elements (initial values for a game to start) shown in the class diagram
                            with according mulitplicity. </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>Static.xml</em></span>: Combines and transforms current
                            gamestates from server with static measurement input values to create an
                            SVG file that displays the Mancala board. Contains a number of
                            measurement input values (such as horizontal/vertiacal distance between
                            houses, distance between stores and nearest houses etc), so that the
                            Mancala board can be automatically created (see "Transform.xsl").
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>mancala.xqm</em></span>: Contains all methods described in the
                            class diagram. </p></li></ul></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e219"></a>OOP, namespaces and naming conventions</h3></div></div></div><p>In order to realise the architecture represented in the classdiagram we introduced
                multiple namespaces, to simulate class-scopes. Each namespace represents a class and
                each method of that class is defined inside that namespace. Every class is in its
                own file and is separated into a public and a private section. Similar to 'self' in
                Python, the $this-reference of the current object is passed as the first parameter
                of every method.</p><div class="section"><div class="titlepage"><div><div><h4 class="title"><a name="d5e222"></a>Naming conventions</h4></div></div></div><p> Public methods are named as is, private methods are prefixed with an
                    underscore. Getter do not have the prefix 'get', setter are prefixed with 'set'.
                    A method returning a boolean is prefixed with 'is' (e.g. seedCount,
                    setSeedCount, isRowEmpty). </p></div></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e225"></a>Index DB</h3></div></div></div><p>TODO: node manipulation by reference</p><p>TODO: IndexDB for games: At first startup, the index-db has to be
                initialized.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e229"></a>Single Node Updates</h3></div></div></div><p>As XQuery updates are gathered and applied at once the end of the XQuery script,
                nodes cannot be updated multiple times. In addition, updated values are not visible
                until the next query. We deal with this problem in two ways: 1. Precompute values.
                This increases the complexity of the seed distribution, but guarantees that no two
                updates on the same nodes are executed in one query 2. To issue an update statement
                and access the same updated values in a GET request, a forward statement is used.
                The called method updates the database and forwards the client to another method,
                where the updated data is accessible. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e232"></a>FLOWR vs. Updating-statements</h3></div></div></div><p> XQuery FLOWR statements cannot be used in conjunction with updating statements
                because of the delayed-updates issue described above. By marking a function
                    <span class="emphasis"><em>updating</em></span>, FLWOR statements cannot be used inside the
                function scope. To mitigate this issue, updating functions use getters on composite
                objects instead of local <span class="emphasis"><em>let</em></span> variables. As a consequence let
                statements are inaccessible, forcing us to use getter methods for every time a
                variable would be used. Recursion is used as a replacement for loops, most noticable
                in the algorithm distributing the seeds. </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e237"></a>Graphical User Interface (GUI)</h3></div></div></div><p>The project's homepage delivers the main GUI, which is an SVG file as shown
                below:</p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/Initial_Board.svg"></object></div><p> The shown Mancala board contains: </p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> 12 houses, 6 for each player. Player 1 owns the upper houses, player
                            2 the lower. </p></li><li class="listitem"><p> 2 stores, 1 for each player. Player 1's store is on the left and
                            player 2's on the right. </p></li><li class="listitem"><p> Game buttons, such as:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: circle; "><li class="listitem"><p>
                                    <span class="emphasis"><em>New Game</em></span>: creates a new game instance
                                    without affecting players' scores. </p></li><li class="listitem"><p>
                                    <span class="emphasis"><em>Reset Scores</em></span>: creates a new game instance
                                    and reset ALL players' scores. </p></li></ul></div></li><li class="listitem"><p> The text in the middle indicates current game status, for example:
                            which player is playing or if one player has won. Players' turns are
                            hinted by a typical color and a blinking triangle in the corresponding
                            store. In case of winning, the status text in the middle will point to
                            the left or right depending on which player has won. </p></li><li class="listitem"><p> Each house is a clickable object. However, the current player can
                            only select his own stores that have positive (&gt; 0) number of stones. In
                            addition the shown digits, the corresponding amount of stones is also
                            displayed as a set of dots, each of which represents one stone. </p></li></ul></div><p> An example of a gamestate after several turns: </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/In_Game_Board.svg"></object></div><p> An example of a gamestate, in which player 1 has won: </p><div class="mediaobject"><object type="image/svg+xml" data="../.././../Diagrams/End_Game_Board.svg"></object></div><p>
            </p><p> The main process of storing and transforming data from server to GUI as an SVG
                file can be described in the following steps: </p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem"><p>
                            <span class="emphasis"><em>SVG outline definition</em></span>: The board's "skeleton" is
                            defined by <span class="emphasis"><em>Static.xml</em></span> stored in the server. This
                            XML file contains very few static measurements that draws the GUI's
                            layout, such as width, height, distance between objects etc. Based on
                            these values, the rest can be automatically computed in the later stage,
                            which hence ensures the model's flexibility and easiness for later
                            adjustment. Styles for these objects (e.g. houses, stores, seeds etc.)
                            are also stored and can be adjusted anytime. In this step, the most
                            important part is to organize required tags in a meaning structure.
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>SVG data source</em></span>: Game data (such as number of seeds
                            in each house, whose turn it is etc.) is store in the server and can be
                            retrieved by a RESTful request. The gamestate fetched can then be
                            processed and displayed on the board. The gamestate is seperated from
                            the static measurements to save storage space and increase request
                            processing time. The data source must conform to the SVG outline.
                        </p></li><li class="listitem"><p>
                            <span class="emphasis"><em>SVG transformation</em></span>:
                                <span class="emphasis"><em>Transform.xsl</em></span> combines both SVG outline and
                            data source into one single SVG file, which is displayed by default on
                            the project's homepage (i.e. http://localhost:8984/). Based on the two
                            XML sources, the XSL file calculates, creates, aligns and assigns styles
                            to all objects shown on the board. Some of the techniques that are used
                            to implement the transformation are:</p><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p>
                                    <span class="emphasis"><em>&lt;defs&gt;</em></span> and
                                        <span class="emphasis"><em>&lt;use&gt;</em></span> tags to reuse
                                    objects</p></li><li class="listitem"><p>
                                    <span class="emphasis"><em>&lt;if&gt;</em></span> or
                                        <span class="emphasis"><em>&lt;choose&gt;</em></span>,
                                        <span class="emphasis"><em>&lt;when&gt;</em></span> and
                                        <span class="emphasis"><em>&lt;otherwise&gt;</em></span> tags to handle
                                    different data states</p></li><li class="listitem"><p>
                                    <span class="emphasis"><em>&lt;call-template&gt;</em></span> and
                                        <span class="emphasis"><em>&lt;template&gt;</em></span> tags to enable
                                    recursion with parameters over repeated work </p></li></ul></div></li></ol></div><p>
            </p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e296"></a>TODOs</h3></div></div></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><table border="0" summary="Warning"><tr><td rowspan="2" align="center" valign="top" width="25"><img alt="[Warning]" src="file:/Applications/oxygenDeveloper/frameworks/docbook/css/img/warning.png"></td><th align="left">Warning</th></tr><tr><td align="left" valign="top"><div class="itemizedlist"><ul class="itemizedlist" style="list-style-type: disc; "><li class="listitem"><p> Eine Beschreibung der Requests und Responses zwischen Client und
                            Server nach dem REST-Prinzip und ihre Abbildung auf Queries mit restXQ.
                        </p></li><li class="listitem"><p> Eine Beschreibung der Benutzeroberfl&auml;che f&uuml;r die verschiedenen
                            Stadien des Spiels mit den jeweiligen Interaktionsm&uuml;glichkeiten. </p></li></ul></div></td></tr></table></div></div></div><div class="section"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d5e304"></a>Future Work</h2></div></div></div><p>The game could be improved by adding the following additional features</p><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e307"></a>Play against the computer</h3></div></div></div><p>The player has the possibility to choose between playing against a real opponent
                or against the computer. When a game against the computer is selected, the player
                can chose the difficulty level of the game. There are 3 options available - easy,
                medium, difficult.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e310"></a>Allow multiple pairs of users to play simultaneously</h3></div></div></div><p>Currently, the mancala application can only save the state of one game which
                limits it to allowing only two users to play. In order to extend the service and
                support a multiple number of games simultaneously, each game state should be
                preserved separatelly.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e313"></a>User Ranking</h3></div></div></div><p>Allowing multiple games at the same time asumes a bigger number of users. Adding a
                user ranking and statistics would provide the players with a better overview of
                their own performance as well as of their competitors. The statistics could be
                integrated into each user's profile, showing the amount of games he/she won or lost.
                A hall of fame listing the best 5 players of all time could be an additional
                motivation for the users.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e316"></a>User Network</h3></div></div></div><p>Building a user network allows the inegration of many additional features which
                can improve the user experience. As mentoined above, each use will have a profile
                that shows his statistics. The profile will also be visible for other players.
                Additional features could include challenging a user, chat as well as offline
                messaging.</p></div><div class="section"><div class="titlepage"><div><div><h3 class="title"><a name="d5e319"></a>Animation</h3></div></div></div><p>Adding animation and special effects to the game play would also have a positive
                impact on the user experience. An example for such special effects is animating the
                movement of the seeds or adding sound effects when a seed get into the user's
                store.</p></div></div></div></body></html>